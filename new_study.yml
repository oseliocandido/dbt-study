- No dia da prova, testar idioma layout do teclado pra ver se ta ok, pois possa ser que precise digitar
 -- rever tipos de questoes da prova 


-- Macros s√£o .sql com macro dentro dele 


- Target Variables
 -- target.name
 -- target.database
 -- target.schema
 -- target.port

- Estudar return codes of dbt core and dbt cloud

{{ target.name}}


- Ler documentacao e FAQ
- Ler sobre custom problems como 
  --https://discourse.getdbt.com/t/creating-an-error-threshold-for-schema-tests/966

- Hooks 
 -- Rodam antes de models, seeds e snapshots
 -- pre-hooks and post-hooks


-- Geralmente  latest patch version from a specific minor release

Contracts / Constraints
- Only when contract \n\t enforced: true 


constraints:
  - type: primary_key
    columns: ['columnaa','columnb']
  - type: foreign_key
    columns:




Snapshots
- 3 config sao obrigatorios (target_schema, strategy, unique_key)
- Gera 4 campos de metadados 
 -- dbt_valid_to
 -- dbt_valid_from
 -- dbt_updated_at
 -- dbt_scd_id

 - Na strategegia de timestamp, o dbt_update_at vai ser sempre igual a dbt_valid_from
  -- Ver como fica na outra estrategia
 - 

 - Estudar invalidate hard deletes do snapshot
 - target_database = Default eh target.database,se passavado um novo eh overwrite por cima
 - target_schema = Obrigatorio e nao eh mesma coisa do target gerado pelo generate_schema_name dos models, seeds e tests

Variables
- Definido em dbt_project.yml
- dbt run --vars 
- Precedence Order
 -- CLI Args
 -- Scope Var
 -- Root Global Var
 -- Default Arg if not provided




Testar no meu codigo chamar macro, ver como faz, sintaxe, etc

Sources
- Se nao passar custom schema, schema vai ser name:
- Se nao passar custom database, database vai ser target.database:


- Quando materializa mesmo relation como table, a view antiga eh deletada, very nice

catalog.json e index.html foram gerados com dbt docs generate


Referenced by  eh quando eh usado downstream